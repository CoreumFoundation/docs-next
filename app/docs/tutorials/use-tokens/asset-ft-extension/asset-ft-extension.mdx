# Asset FT Extension

The tutorial provides an example of how to develop, deploy and use WASM contracts to be used as fungible smart token extension.

## Prerequisites

To complete this tutorial, you need to:

* Install <a className="text-[#24D494] font-bold text-base" href="https://www.rust-lang.org/tools/install" target="_blank">rust and cargo</a>.
* Be familiar with the Rust programming language.
* Have a general understanding of how the Coreum blockchain works.
* Follow the [instruction](/docs/tutorials/get-started/install-cored) to install cored binary.
* Install the required util: `jq`.
* Set the [network variables](/docs/tutorials/get-started/setup-cli) for the development (testnet is preferable).

## Source Code
The source code is located <a className="text-[#24D494] font-bold" href="https://github.com/CoreumFoundation/tutorials/tree/main/wasm/extension" target="_blank">here</a>.
You can see different examples by checking out different branches of this repository.

## Getting Started

* Clone the smart contract template

```bash
git clone https://github.com/CoreumFoundation/tutorials.git
```

* Go to the contract directory.

```bash
cd tutorials/wasm/extension-ft-with-dex
```

* Generate a new account

```bash
cored keys add ft-admin $COREUM_CHAIN_ID_ARGS
cored keys add ft-receiver-1 $COREUM_CHAIN_ID_ARGS
cored keys add ft-receiver-2 $COREUM_CHAIN_ID_ARGS
```

* Fund account

Use the [faucet](/docs/tools/faucet) to fund your account

* Export commonly used, throughout the tutorial, environment variables.

```bash
export FT_ADMIN=$(cored keys show ft-admin --address $COREUM_CHAIN_ID_ARGS)
export FT_RECEIVER_1=$(cored keys show ft-receiver-1 --address $COREUM_CHAIN_ID_ARGS)
export FT_RECEIVER_2=$(cored keys show ft-receiver-2 --address $COREUM_CHAIN_ID_ARGS)
```

* Check the balance

```bash
cored q bank balances $FT_ADMIN $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
```

## Build contract

* Build the contract

```bash
docker run --rm -v "$(pwd)":/code \
  --mount type=volume,source="$(basename "$(pwd)")_cache",target=/target \
  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \
  cosmwasm/optimizer:0.16.1
```

This operation might take a significant amount of time.

## Deploy contract

* Deploy the built artifact.

```bash
RES=$(cored tx wasm store artifacts/extension.wasm \
    --from $FT_ADMIN --gas auto --gas-adjustment 1.4 -y -b block --output json $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS)
echo $RES
CODE_ID=$(echo $RES | jq -r '.events[-1].attributes[-2].value')
echo "Code ID: $CODE_ID"
```

* Check the deployed code.

```bash
cored q wasm code-info $CODE_ID $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
```

In order to use the deployed contract as an asset extension, you don't need to instantiate it. It will be instantiated automatically when issuing the token.

## Issue token

* Issuing the smart token with extension

Now we have a wasm smart contract that can be used as an extension to a smart token.
We can issue a new token like explain in [Create and Manage FT with CLI](/docs/tutorials/use-tokens/create-and-manage-ft-with-cli) but pass additional params for the extension.

Use the following command to issue your FT with extension:

```bash
cored tx assetft issue MYFT cmyft 2 100000000 "My FT token with extension" --from $FT_ADMIN --features=burning,minting,extension --burn-rate=0.02 --send-commission-rate=0.03 --extension-code-id=$CODE_ID --extension-label=my-extension $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS -y -b block --gas auto --gas-adjustment 1.4
```

* On token `instantiation` we can set custom parameters we allow to set in the contract related to extension.
* extension-code-id - CodeID of the deployed wasm contract
* extension-label - optional label to assign to the extension
* extension_funds - optional funds to transfer to the contract when instantiating the token
* extension_issuance_msg - optional json encoded data to pass to WASM on instantiation by the ft issuer

* Build denom and query supply.

```bash
export FT_DENOM=cmyft-$FT_ADMIN
```

```bash
cored q bank total-supply-of $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "100000000"
```

```bash
cored q bank denom-metadata $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
```

```bash
cored q assetft token $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
```

* Capture the contract address.

```bash
RES=$(cored q assetft token $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS --output json)
EXTENSION_ADDR=$(echo $RES | jq -r '.token.extension_cw_address')
echo "Extension Address: $EXTENSION_ADDR"
```

## Interactions with the extension (transfer)

When we issue a token with extension, every bank transfer of this token will be intercepted and instead of the recipient,
it will be sent to the smart contract used as asset extension and then the contract decides what to do with it.

The smart contract may decide to send the tokens to the recipient or not, return it to the sender, send it to multiple
accounts, burn a part of it, mint some more coins to send as a reward, apply features like, commission rate, burn rate or any custom logic.
We will implement some of these ideas, but first, let's understand the flow.

Let's say alice sends `100$FT_DENOM` to bob. This transaction will be intercepted and transferred to `$EXTENSION_ADDR`.
If asset FT features are enable (e.g. whitelisting, freezing) they will be checked before the calling the smart contract.
Then `sudo` entrypoint of the contract will be called with `ExtensionTransfer` message.

Code:

```rust
#[entry_point]
pub fn sudo(deps: DepsMut, env: Env, msg: SudoMsg) -> Result<Response, ContractError> {
    match msg {
        SudoMsg::ExtensionTransfer {
            sender,
            recipient,
            transfer_amount,
            commission_amount,
            burn_amount,
            context,
        } => sudo_extension_transfer(
            deps,
            env,
            transfer_amount,
            sender,
            recipient,
            commission_amount,
            burn_amount,
            context,
        ),
        SudoMsg::ExtensionPlaceOrder {
            order,
            expected_to_spend,
            expected_to_receive,
        } => sudo_extension_place_order(order, expected_to_spend, expected_to_receive),
    }
}

```

In the code snippet above in the `SudoMsg` enum, we declare the functions to be called. The `sudo` function marked with `entry_point` macro routes them to the proper handlers.
`ExtensionTransfer -> sudo_extension_transfer` - when a bank transfer is initiated. `ExtensionPlaceOrder -> sudo_extension_place_order` - when an DEX order is placed.
Read <a className="text-[#24D494] font-bold" href="/docs/overview/smart-tokens#extension" target="_blank">smart-tokens/extension</a> to get more info about the message attributes.

Now, let's implement some of those ideas, starting with the most basic one to just keep the amount in the extension address.
As described before, the coins are first transferred to the extension, then it should decide. It can just decide to do nothing.
The template code that we deployed is going to do just that.

Code:

```rust

pub fn sudo_extension_transfer(
    _deps: DepsMut,
    _env: Env,
    _amount: Uint128,
    _sender: String,
    _recipient: String,
    _commission_amount: Uint128,
    _burn_amount: Uint128,
    _context: TransferContext,
) -> Result<Response, ContractError> {
    Ok(Response::new())
}

pub fn sudo_extension_place_order(
    _order: DEXOrder,
    _expected_to_spend: Coin,
    _expected_to_receive: Coin,
) -> Result<Response, ContractError> {
    Ok(Response::new())
}

```

_**Note**: If `sudo_extension_place_order` handler is not implemented you will be able to send the token, but won't be able to place an DEX order with the token._

We can test transfer handler by sending some about to an account. The account won't receive it, but the extension will have it instead.

```bash
cored tx bank send $FT_ADMIN $FT_RECEIVER_1 10$FT_DENOM -y -b block $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
```

* Check balance

```bash
cored q bank balance $FT_ADMIN $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "99999988"
```

```bash
cored q bank balance $FT_RECEIVER_1 $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "0"
```

```bash
cored q bank balance $EXTENSION_ADDR $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "12"
```

### A simple bank transfer.

Now let's change the code to send the amount as it should be without the extension like a normal bank transfer.
With our current setup, we only need to modify `sudo_extension_transfer` function to achieve what we want.

Code:

```rust

pub fn sudo_extension_transfer(
    deps: DepsMut,
    _env: Env,
    amount: Uint128,
    _sender: String,
    recipient: String,
    _commission_amount: Uint128,
    _burn_amount: Uint128,
    _context: TransferContext,
) -> Result<Response, ContractError> {
    let denom = DENOM.load(deps.storage)?;

    let transfer_msg = cosmwasm_std::BankMsg::Send {
        to_address: recipient.to_string(),
        amount: vec![Coin { amount, denom }],
    };

    let response = Response::new()
        .add_attribute("method", "execute_transfer")
        .add_message(transfer_msg);

    Ok(response)
}
```

* Build the contract again and deploy the built artifact.

```bash
RES=$(cored tx wasm store artifacts/extension.wasm \
    --from $FT_ADMIN --gas auto --gas-adjustment 1.4 -y -b block --output json $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS)
echo $RES
CODE_ID=$(echo $RES | jq -r '.events[-1].attributes[-2].value')
echo "Code ID: $CODE_ID"
```

We can either issue a new token with our new extension, or we can migrate the extension code of our previous token.

* Migrate the extension code.

```bash
cored tx wasm migrate $EXTENSION_ADDR $CODE_ID '{}' --from $FT_ADMIN -y -b block $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
```

Now if we send some amount, it will be transferred normally.

```bash
cored tx bank send $FT_ADMIN $FT_RECEIVER_1 10$FT_DENOM -y -b block $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
```

* Check balance

```bash
cored q bank balance $FT_ADMIN $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "99999976"
```

```bash
cored q bank balance $FT_RECEIVER_1 $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "10"
```

We see that 10 coins are transferred from `$FT_ADMIN` to `$FT_RECEIVER_1`.

### Reject some transactions.

Let's add an arbitrary rule to reject any bank transfer, sending 7 coins.

Code:

```rust

pub fn sudo_extension_transfer(
    deps: DepsMut,
    _env: Env,
    amount: Uint128,
    _sender: String,
    recipient: String,
    _commission_amount: Uint128,
    _burn_amount: Uint128,
    _context: TransferContext,
) -> Result<Response, ContractError> {
    let denom = DENOM.load(deps.storage)?;

    if amount == Uint128::new(7) {
        return Err(ContractError::Std(StdError::generic_err(
            "7 is not allowed",
        )));
    }

    let transfer_msg = cosmwasm_std::BankMsg::Send {
        to_address: recipient.to_string(),
        amount: vec![Coin { amount, denom }],
    };

    let response = Response::new()
        .add_attribute("method", "execute_transfer")
        .add_message(transfer_msg);

    Ok(response)
}
```

* Build the contract, deploy the built artifact and migrate the extension code again.

Now if we send exactly 7 coins, it will be rejected with `7 is not allowed` error.

```bash
cored tx bank send $FT_ADMIN $FT_RECEIVER_1 7$FT_DENOM -y -b block $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# 7 is not allowed
```

* Check balance

```bash
cored q bank balance $FT_ADMIN $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "99999976"
```

```bash
cored q bank balance $FT_RECEIVER_1 $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "10"
```

Since the transaction is rejected, we can see that the balance of none of the accounts are changed.

### Custom send commission rate.

For this example, we want to implement send commission rate feature in the extension, but the commission is split between
the extension and the token admin.

Code:

```rust

pub fn sudo_extension_transfer(
    deps: DepsMut,
    _env: Env,
    amount: Uint128,
    _sender: String,
    recipient: String,
    commission_amount: Uint128,
    _burn_amount: Uint128,
    _context: TransferContext,
) -> Result<Response, ContractError> {
    let denom = DENOM.load(deps.storage)?;
    let token = query_token(deps.as_ref(), &denom)?;

    let transfer_msg = cosmwasm_std::BankMsg::Send {
        to_address: recipient.to_string(),
        amount: vec![Coin { amount, denom }],
    };

    let mut response = Response::new()
        .add_attribute("method", "execute_transfer")
        .add_message(transfer_msg);

    if !commission_amount.is_zero() {
        // if token has an admin, send half of the commission to the admin and let the extension keep
        // the rest of the commission
        if let Some(admin) = token.admin.into() {
            let admin_commission_amount = commission_amount.div(Uint128::new(2));
            let admin_commission_msg = cosmwasm_std::BankMsg::Send {
                to_address: admin.to_string(),
                amount: vec![Coin {
                    amount: admin_commission_amount,
                    denom: token.denom.to_string(),
                }],
            };
            response = response
                .add_attribute(
                    "admin_send_commission_amount",
                    admin_commission_amount.to_string(),
                )
                .add_message(admin_commission_msg);
        }
    }
    Ok(response)
}

fn query_token(deps: Deps, denom: &str) -> StdResult<Token> {
    let request = QueryTokenRequest {
        denom: denom.to_string(),
    };
    let token: QueryTokenResponse = request.query(&deps.querier)?;
    Ok(token.token.unwrap_or_default())
}

```

* Build the contract, deploy the built artifact and migrate the extension code again.

Now if we send 200 coins to another account, the commission would be 200 * 0.03 = 6, which will be split between admin
and extension, so each one will receive 3 coins as commission.

Let's check the sender (`$FT_ADMIN`), the recipient (`$FT_RECEIVER_1`) and the extension (`$EXTENSION_ADDR`)'s balance before send.

* Check balances

```bash
cored q bank balance $FT_ADMIN $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "99999976"
```

```bash
cored q bank balance $FT_RECEIVER_1 $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "10"
```

```bash
cored q bank balance $EXTENSION_ADDR $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "14"
```

* Send tokens

```bash
cored tx bank send $FT_ADMIN $FT_RECEIVER_1 200$FT_DENOM --gas auto --gas-adjustment 1.2 -y -b block $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
```

* Check balances again

```bash
cored q bank balance $FT_ADMIN $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "99999769"
```

```bash
cored q bank balance $FT_RECEIVER_1 $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "210"
```

```bash
cored q bank balance $EXTENSION_ADDR $FT_DENOM $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# amount: "21"
```

We see that admin has 207 fewer coins (-200 -6 \[commission amount\] -4 \[burn amount\] +3 \[50% commission refund\] =
-207), recipient has 200 more coins and the extension has 3 more coins \[50% commission refund\].

### Custom ibc.

As the last example, let's say we want to disallow ibc transfer more than an arbitrary amount, like 100 tokens, but
allow other amounts.

Code:

```rust
pub fn sudo_extension_transfer(
    deps: DepsMut,
    _env: Env,
    amount: Uint128,
    _sender: String,
    recipient: String,
    _commission_amount: Uint128,
    _burn_amount: Uint128,
    context: TransferContext,
) -> Result<Response, ContractError> {
    let denom = DENOM.load(deps.storage)?;

    if matches!(context.ibc_purpose, IBCPurpose::Out) && amount > Uint128::new(100) {
        return Err(ContractError::Std(StdError::generic_err(
            "IBC is disabled",
        )));
    }

    let transfer_msg = cosmwasm_std::BankMsg::Send {
        to_address: recipient.to_string(),
        amount: vec![Coin { amount, denom }],
    };

    let response = Response::new()
        .add_attribute("method", "execute_transfer")
        .add_message(transfer_msg);

    Ok(response)
}
```

* Build the contract, deploy the built artifact and migrate the extension code again.

If you transfer some amount more than 100 tokens, it will fail and show the error.

## Interactions with the extension (place order)

When we issue a token with extension, every order placement will be intercepted to let the smart contract
decide whether the placement is allowed or not.

Let's add an arbitrary rule to reject any order if the order's quantity is less than 10.

Code:

```rust

pub fn sudo_extension_place_order(
    order: DEXOrder,
    _expected_to_spend: Coin,
    _expected_to_receive: Coin,
) -> Result<Response, ContractError> {
    if order.quantity < Uint128::new(10) {
        return Err(ContractError::Std(StdError::generic_err(
            "Too small order quantity",
        )));
    }

    Ok(Response::new())
}
```

* Build the contract, deploy the built artifact and migrate the extension code again.

Now if we place and order with the quantity less than 10, the order will be rejected.

```bash
cored tx dex place-order limit id1 $COREUM_DENOM $FT_DENOM 9 SIDE_SELL --time-in-force=TIME_IN_FORCE_GTC --price 1e1 --gas auto --gas-adjustment 1.2 --from $FT_ADMIN -y -b block $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# Too small order quantity
```

* Place the order with the correct quantity now

```bash
cored tx dex place-order limit id1 $COREUM_DENOM $FT_DENOM 11 SIDE_SELL --time-in-force=TIME_IN_FORCE_GTC --price 1e1 --gas auto --gas-adjustment 1.2 --from $FT_ADMIN -y -b block $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
```

```bash
cored q dex orders $FT_ADMIN $COREUM_NODE_ARGS $COREUM_CHAIN_ID_ARGS
# the order should be in the list
```

## Next steps

* Read Coreum [modules](/docs/overview/modules) specification, to be familiar with the custom Coreum functionality you can
use for your extension.
* Read <a className="text-[#24D494] font-bold" href="https://docs.cosmwasm.com/docs/" target="_blank">WASM docs</a> to understand all supported WASM features.
* Check other [tutorials](/docs/overview/tutorials) to find something you might be interested in additionally.
